/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#define RCC_APB2ENR (*(unsigned int*) 0x40021018)
#define RCC_APB1ENR (*(unsigned int*) 0x4002101C)

#define GPIOA 		(*(unsigned int*) 0x40010800)
#define GPIOB 		(*(unsigned int*) 0x40010C00)
#define GPIOC 		(*(unsigned int*) 0x40011000)
#define GPIOD 		(*(unsigned int*) 0x40011400)

#define ADC1 		(*(unsigned int*) 0x40012400)
#define ADC2 		(*(unsigned int*) 0x40012800)

#define GPIOA_CRL 	(*(unsigned int*)0x40010800)
#define GPIOA_CRH 	(*(unsigned int*)0x40010804)
#define GPIOA_IDR 	(*(unsigned int*)0x40010808)
#define GPIOA_ODR 	(*(unsigned int*)0x4001080C)
#define GPIOA_BSRR 	(*(unsigned int*)0x40010810)
#define GPIOA_BRR 	(*(unsigned int*)0x40010814)

#define GPIOB_CRL 	(*(unsigned int*)0x40010C00)
#define GPIOB_CRH 	(*(unsigned int*)0x40010C04)
#define GPIOB_IDR 	(*(unsigned int*)0x40010C08)
#define GPIOB_ODR 	(*(unsigned int*)0x40010C0C)
#define GPIOB_BSRR 	(*(unsigned int*)0x40010C10)
#define GPIOB_BRR 	(*(unsigned int*)0x40010C14)

#define GPIOC_CRL 	(*(unsigned int*)0x40011000)
#define GPIOC_CRH 	(*(unsigned int*)0x40011004)
#define GPIOC_IDR 	(*(unsigned int*)0x40011008)
#define GPIOC_ODR 	(*(unsigned int*)0x4001100C)
#define GPIOC_BSRR 	(*(unsigned int*)0x40011010)
#define GPIOC_BRR 	(*(unsigned int*)0x40011014)

#define GPIOD_CRL 	(*(unsigned int*)0x40011400)
#define GPIOD_CRH 	(*(unsigned int*)0x40011404)
#define GPIOD_IDR 	(*(unsigned int*)0x40011408)
#define GPIOD_ODR 	(*(unsigned int*)0x4001140C)
#define GPIOD_BSRR 	(*(unsigned int*)0x40011410)
#define GPIOD_BRR 	(*(unsigned int*)0x40011414)

#define ADC1_CR2 	(*(unsigned int*) 0x40012408)
#define ADC1_SQR1 	(*(unsigned int*) 0x4001242C)
#define ADC1_SQR2 	(*(unsigned int*) 0x40012430)
#define ADC1_SQR3 	(*(unsigned int*) 0x40012434)
#define ADC1_DR 	(*(unsigned int*) 0x4001244C)
#define ADC1_SMPR2 	(*(unsigned int*) 0x40012410)
#define ADC1_SR 	(*(unsigned int*)0x40012400)

#define TIM3 		(*(unsigned int*) 0x40000400)
#define TIM3_PSC 	(*(unsigned int*) 0x40000428)
#define TIM3_ARR 	(*(unsigned int*) 0x4000042C)
#define TIM3_CCR2 	(*(unsigned int*) 0x40000438)
#define TIM3_CCER 	(*(unsigned int*) 0x40000420)
#define TIM3_CCMR1 	(*(unsigned int*) 0x40000418)
#define TIM3_CR1 	(*(unsigned int*) 0x40000400)
#define TIM3_EGR 	(*(unsigned int*) 0x40000414)

#define TIM2		(*(unsigned int*) 0x40000000)
#define TIM2_PSC 	(*(unsigned int*) 0x40000028)
#define TIM2_ARR 	(*(unsigned int*) 0x4000002C)
#define TIM2_CCR2 	(*(unsigned int*) 0x40000038)
#define TIM2_CCER 	(*(unsigned int*) 0x40000020)
#define TIM2_CCMR1 	(*(unsigned int*) 0x40000018)
#define TIM2_CR1 	(*(unsigned int*) 0x40000000)
#define TIM2_EGR 	(*(unsigned int*) 0x40000014)
#define TIM2_SR 	(*(unsigned int*) 0x40000010)
#define TIM2_DIER	(*(unsigned int*) 0x4000000C)

#define EXTI_IMR 	(*(unsigned int*) 0x40010400)
#define EXTI_EMR	(*(unsigned int*) 0x40010404)
#define EXTI_RTSR	(*(unsigned int*) 0x40010408)
#define EXTI_FTSR	(*(unsigned int*) 0x4001040C)
#define EXTI_SWIER	(*(unsigned int*) 0x40010410)
#define EXTI_PR		(*(unsigned int*) 0x40010414)

#define NVIC_ISER0 (*(unsigned int*) 0xE000E100)
#define EXTI4_PR (*(unsigned int*) 0x40010414)
#define EXTI 0x40010400
#define AFIO 0x40010000
#define NVIC 0xE000E100
#define AFIO_EXTICR2 (*(unsigned int*) 0x4001000C)



#include <stdint.h>


static uint16_t adc_value;
static uint32_t led_delay;
volatile uint8_t btn_flag = 0; // 전역 변수 선언
volatile uint8_t stop_mode = 0;
volatile uint8_t seg_index = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void LEDs_sqeuence();
void delay_loop(uint32_t time);
void seven_seg(uint16_t adc_value);
void print_segment(uint8_t number);
void print_stop();
void print_fast();

int main(void)
{
	/**************CLK Setting**************/
	RCC_APB2ENR |= (1 << 2); // GPIOA EN
	RCC_APB2ENR |= (1 << 3); // GPIOB EN
	RCC_APB2ENR |= (1 << 4); // GPIOC EN
	RCC_APB2ENR |= (1 << 5); // GPIOD EN

	RCC_APB1ENR |= (1 << 1); // TIM3 EN
	RCC_APB2ENR |= (1 << 0); // AFIO EN

	// ADC CLK
	RCC_APB2ENR |= (1 << 9); // ADC1 EN
	RCC_APB2ENR |= (1 << 10); // ADC2 EN

	/*************************************/


	/***************LEDs GPIO SET ******************/

	/*
	- **PC5 - LED_1**
	- **PB0 - LED_2**
	- **PB1 - LED_3**
	- **PB2 - LED_4**
	- **PB10 - LED_5**
	- **PB11 - LED_6**
	*/

	GPIOA_CRL &= ~(0xF << 24); // ADC PA6 SET

	GPIOC_CRL &= ~(0xF << 20); // PC5 Clear
	GPIOC_CRL |= (1<<20);
	GPIOB_CRL &= ~(0xF << 0); // PB0 Clear
	GPIOB_CRL |= (1<<0);
	GPIOB_CRL &= ~(0xF << 4); // PB1 Clear
	GPIOB_CRL |= (1<<4);
	GPIOB_CRL &= ~(0xF << 8); // PB2 Clear
	GPIOB_CRL |= (1<<8);
	GPIOB_CRH &= ~(0xF << 8); // PB10 Clear
	GPIOB_CRH |= (1<<8);
	GPIOB_CRH &= ~(0xF << 12); // PB11 Clear
	GPIOB_CRH |= (1<<12);
	/***********************************************/

	GPIOC_BRR = (1 << 5);
	GPIOB_BRR = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 10) | (1 << 11);


	/**********************7-Segment GPIO Set**************************/

	/*
		- **PA12 - DIG_A**
		- **PA11 - DIG_B**
		- **PA10 - DIG_C**
		- **PA9 - DIG_D**
		- **PA8 - DIG_E**
		- **PC9 - DIG_F**
		- **PC8 - DIG_G**
		- **PC7 - DIG_H**
		- **PC6 - DIG_1_com**
		- **PB15 - DIG_2_com**
		- **PB14 - DIG_3_com**
		- **PB13 - DIG_4_com**
	 */
	GPIOA_CRH &= ~(0xF << 16); // PA12 Clear
	GPIOA_CRH |= (1<<16);

	GPIOA_CRH &= ~(0xF << 12); // PA11 - DIG_B
	GPIOA_CRH |= (1<<12);

	GPIOA_CRH &= ~(0xF << 8); // PA10 - DIG_C
	GPIOA_CRH |= (1<<8);

	GPIOA_CRH &= ~(0xF << 4);  //PA9 - DIG_D
	GPIOA_CRH |= (1<<4);

	GPIOA_CRH &= ~(0xF << 0); // PA8 - DIG_E
	GPIOA_CRH |= (1<<0);

	GPIOC_CRH &= ~(0xF << 4); // PC9 - DIG_F
	GPIOC_CRH |= (1<<4);

	GPIOC_CRH &= ~(0xF << 0); // PC8 - DIG_G
	GPIOC_CRH |= (1<<0);

	GPIOC_CRL &= ~(0xF << 28); // PC7 - DIG_H
	GPIOC_CRL |= (1<<28);

	GPIOC_CRL &= ~(0xF << 24); // PC6 - DIG_1_com
	GPIOC_CRL |= (1<<24);

	GPIOB_CRH &= ~(0xF << 28); // PB15 - DIG_2_com
	GPIOB_CRH |= (1<<28);

	GPIOB_CRH &= ~(0xF << 24); //PB14 - DIG_3_com
	GPIOB_CRH |= (1<<24);

	GPIOB_CRH &= ~(0xF << 20); //PB13 - DIG_4_com
	GPIOB_CRH |= (1<<20);

	/*********************************************************/

	/**********************ADC************************/

	ADC1_CR2 |= (1<<0); // ADC전원 ON
	for (volatile int i = 0; i < 10000; i++); //안정화 대기


	ADC1_SMPR2 |= (7<<18);
	ADC1_SQR3 = 6;
	ADC1_CR2 |= (1<<1);
	ADC1_CR2 |= (1<<22);
	ADC1_CR2 |= (1<<0);
	/************************************************/


	/***********************PWM***************************/

	GPIOA_CRL &= 	~(0xF << 28); // PA7 CRL
	GPIOA_CRL |= 	(0xB << 28);  // PA7 AFIO Set 1011

	// 3. PWM 기본 설정
	TIM3_PSC = 72 - 1;       // 1 MHz
	TIM3_ARR = 20000 - 1;    // 20ms (50Hz)
	TIM3_CCR2 = 1500;        // Duty 7.5%

	TIM3_CCMR1 &= ~(7<<12);
	TIM3_CCMR1 |= (6<<12);
	TIM3_CCMR1 |= (1<<11);
	TIM3_CCER |= (1<<4);

	TIM3_CR1 |= (1 << 7);
	TIM3_EGR |= (1 << 0);
	TIM3_CR1 |= (1 << 0);
	/*****************************************************/



	/******************************Interrupt***********************************/
	//PC5를 gpio output으로 설정
	GPIOC_CRL &= ~(0xF << 20);
	GPIOC_CRL |= (1<<20);

	//PC4 입력
	GPIOC_CRL &= ~(0xF << 16);
	GPIOC_CRL |= (2<<18);
	GPIOC_ODR  |=  (1 << 4);     // Pull-up 활성화

	//EXTI 2초기화
	AFIO_EXTICR2 &= ~(0xF<<0);
	//EXTI PC interrupt 설정
	AFIO_EXTICR2 |= (0x2<<0);

	EXTI_IMR |= (1<<4);
	EXTI_FTSR |= (1<<4);


	//NVIC IRQ 설정
	NVIC_ISER0 |= (1<<10);
	/***************************************************************************/


	/***********Improved*************/
	RCC_APB1ENR |= (1 << 0); //TIM2 EN
	TIM2_PSC = 7200-1;
	TIM2_ARR = 10 - 1;

	TIM2_DIER |= (1 << 0);  // UIE (Update Interrupt Enable)
	TIM2_CR1  |= (1 << 0);  // CEN (Timer Enable)
	NVIC_ISER0 |= (1 << 28); // IRQ28은 TIM2 (NVIC 벡터 참고)

	/********************************/

    /* Loop forever */
	while(1){

	    if (btn_flag)
	    {
	        btn_flag = 0;
	        stop_mode = !stop_mode;  // 토글
	    }

	    if (stop_mode)
	    {
	        print_stop();  // stop 상태 유지
	        continue;      // 아래 ADC, PWM 무시
	    }

		ADC1_CR2 |= (1 << 22);   // SWSTART trigger
		while (!(ADC1_SR & (1 << 1)));     // EOC (End of Conversion) 기다림
		adc_value = (uint16_t)ADC1_DR;     // 결과 레지스터 읽기

		if(adc_value > 4000){
			print_fast();
		}
		else if(adc_value < 1000){
			print_stop();
		}
		else{
			LEDs_sqeuence();
			//seven_seg(adc_value);
			TIM3_CCR2 = adc_value / 4;
		}
	}
}

void LEDs_sqeuence()
{
	const uint32_t delay_table[8] = {300000, 200000, 130000, 80000, 50000, 30000, 15000, 7000};
	uint8_t level = adc_value / 512;  // 0~7
	led_delay = delay_table[level];


	for(int i=0; i<6; i++){
		switch(i){
			case 0:
				GPIOC_BSRR = (1<<5);
				GPIOB_BRR = (1<<0);
				GPIOB_BRR = (1<<1);
				GPIOB_BRR = (1<<2);
				GPIOB_BRR = (1<<10);
				GPIOB_BRR = (1<<11);
				break;
			case 1:
				GPIOC_BRR = (1<<5);
				GPIOB_BSRR = (1<<0);
				GPIOB_BRR = (1<<1);
				GPIOB_BRR = (1<<2);
				GPIOB_BRR = (1<<10);
				GPIOB_BRR = (1<<11);
				break;
			case 2:
				GPIOC_BRR = (1<<5);
				GPIOB_BRR = (1<<0);
				GPIOB_BSRR = (1<<1);
				GPIOB_BRR = (1<<2);
				GPIOB_BRR = (1<<10);
				GPIOB_BRR = (1<<11);
				break;
			case 3:
				GPIOC_BRR = (1<<5);
				GPIOB_BRR = (1<<0);
				GPIOB_BRR = (1<<1);
				GPIOB_BSRR = (1<<2);
				GPIOB_BRR = (1<<10);
				GPIOB_BRR = (1<<11);
				break;
			case 4:
				GPIOC_BRR = (1<<5);
				GPIOB_BRR = (1<<0);
				GPIOB_BRR = (1<<1);
				GPIOB_BRR = (1<<2);
				GPIOB_BSRR = (1<<10);
				GPIOB_BRR = (1<<11);
				break;
			case 5:
				GPIOC_BRR = (1<<5);
				GPIOB_BRR = (1<<0);
				GPIOB_BRR = (1<<1);
				GPIOB_BRR = (1<<2);
				GPIOB_BRR = (1<<10);
				GPIOB_BSRR = (1<<11);
				break;

		}
		delay_loop(led_delay);
	}
}

//void delay_loop(uint32_t time)
//{
//    for (volatile uint32_t i = 0; i < time; i++);
//}

void seven_seg(uint16_t adc_value)
{

	uint8_t adc_value_1000 = adc_value/1000;     // PC6 - DIG_1_com
	uint8_t adc_value_100 = (adc_value%1000)/100; //PB15 - DIG_2_com
	uint8_t adc_value_10 = (adc_value%100)/10;   //PB14 - DIG_3_com
	uint8_t adc_value_1 = adc_value%10;			 //PB13 - DIG_4_com

	for(int i=0; i<4; i++){
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);

		switch(i){
			case 0:
				GPIOC_BRR = (1<<6);
				print_segment(adc_value_1000);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 1:
				GPIOB_BRR = (1<<15);
				print_segment(adc_value_100);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 2:
				GPIOB_BRR = (1<<14);
				print_segment(adc_value_10);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 3:
				GPIOB_BRR = (1<<13);
				print_segment(adc_value_1); 	//print adc_value_1000
//				delay_loop(1000);
				break;
		}

	}
	/*stop, fast */
	/* 0 1 2 3 4 5 6 7 8 9 */

}

void print_segment(uint8_t number)
{
	/*
		- **PA12 - DIG_A**
		- **PA11 - DIG_B**
		- **PA10 - DIG_C**
		- **PA9 - DIG_D**
		- **PA8 - DIG_E**
		- **PC9 - DIG_F**
		- **PC8 - DIG_G**

		- **PC7 - DIG_H**
		- **PC6 - DIG_1_com**
		- **PB15 - DIG_2_com**
		- **PB14 - DIG_3_com**
		- **PB13 - DIG_4_com**
	 */
	GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
	GPIOC_BRR = (1<<9) | (1<<8);

	switch(number){
		case 0:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 1:
			GPIOA_BRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 2:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 3:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 4:
			GPIOA_BRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 5:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 6:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 7:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 8:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 9:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
	}
	//delay_loop(2000);
}


//void print_fast(void){
//
//	for(int i=0; i<4; i++){
//		GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
//		GPIOC_BRR = (1<<9) | (1<<8);
//
//		GPIOC_BSRR = (1<<6);                // DIG_1 off
//		GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);  // DIG_2~4 off
//		switch(i){
//			case 0:
//				GPIOC_BRR = (1<<6);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BRR = (1<<11); // b
//				GPIOA_BRR = (1<<10); // c
//				GPIOA_BRR = (1<<9); // d
//				GPIOA_BSRR = (1<<8); // e
//				GPIOC_BSRR = (1<<9); // f
//				GPIOC_BSRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//			case 1:
//				GPIOB_BRR = (1<<15);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BSRR = (1<<11); // b
//				GPIOA_BSRR = (1<<10); // c
//				GPIOA_BRR = (1<<9); // d
//				GPIOA_BSRR = (1<<8); // e
//				GPIOC_BSRR = (1<<9); // f
//				GPIOC_BSRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//			case 2:
//				GPIOB_BRR = (1<<14);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BRR = (1<<11); // b
//				GPIOA_BSRR = (1<<10); // c
//				GPIOA_BSRR = (1<<9); // d
//				GPIOA_BRR = (1<<8); // e
//				GPIOC_BSRR = (1<<9); // f
//				GPIOC_BSRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//			case 3:
//				GPIOB_BRR = (1<<13);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BSRR = (1<<11); // b
//				GPIOA_BSRR = (1<<10); // c
//				GPIOA_BRR = (1<<9); // d
//				GPIOA_BRR = (1<<8); // e
//				GPIOC_BRR = (1<<9); // f
//				GPIOC_BRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//		}
//		delay_loop(2000);
//	    GPIOC_BSRR = (1<<6);
//	    GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);
//	}
//}

void print_fast(void)
{
    uint8_t letters[4] = {'F','A','S','T'};
    for(int i=0; i<4; i++)
    {
        // 모든 자리 끄기
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15)|(1<<14)|(1<<13);

        // 모든 segment 끄기
        GPIOA_BRR = (1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8);
        GPIOC_BRR = (1<<9)|(1<<8);

        switch(i)
        {
            case 0: GPIOC_BRR = (1<<6); break;   // DIG_1 ON
            case 1: GPIOB_BRR = (1<<15); break;  // DIG_2 ON
            case 2: GPIOB_BRR = (1<<14); break;  // DIG_3 ON
            case 3: GPIOB_BRR = (1<<13); break;  // DIG_4 ON
        }

        // 글자별 segment 패턴 표시
        switch(letters[i])
        {
            case 'F':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break; // a,f,g
            case 'A':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'S':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'T':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
        }
    }
}

void print_stop(void)
{
    uint8_t letters[4] = {'S','T','O','P'};
    for(int i=0; i<4; i++)
    {
        // 전체 off
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15)|(1<<14)|(1<<13);
        GPIOA_BRR = (1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8);
        GPIOC_BRR = (1<<9)|(1<<8);

        // 자리 선택
        switch(i)
        {
            case 0: GPIOC_BRR = (1<<6); break;
            case 1: GPIOB_BRR = (1<<15); break;
            case 2: GPIOB_BRR = (1<<14); break;
            case 3: GPIOB_BRR = (1<<13); break;
        }

        // 글자 세그먼트 표시
        switch(letters[i])
        {
            case 'S':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'T':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'O':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'P':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
        }
    }
}



//void print_stop(void){
////	GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
////	GPIOC_BRR = (1<<9) | (1<<8);
//
////	GPIOC_BSRR = (1<<6);                // DIG_1 off
////	GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);  // DIG_2~4 off
//
//	for(int i=0; i<4; i++){
//        GPIOC_BSRR = (1<<6);
//        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);
//
//        GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
//        GPIOC_BRR = (1<<9) | (1<<8);
//
//		switch(i){
//			case 0:
//				GPIOC_BRR = (1<<6);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BRR = (1<<11); // b
//				GPIOA_BSRR = (1<<10); // c
//				GPIOA_BSRR = (1<<9); // d
//				GPIOA_BRR = (1<<8); // e
//				GPIOC_BSRR = (1<<9); // f
//				GPIOC_BSRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//			case 1:
//				GPIOB_BRR = (1<<15);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BSRR = (1<<11); // b
//				GPIOA_BSRR = (1<<10); // c
//				GPIOA_BRR = (1<<9); // d
//				GPIOA_BRR = (1<<8); // e
//				GPIOC_BRR = (1<<9); // f
//				GPIOC_BRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//			case 2:
//				GPIOB_BRR = (1<<14);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BSRR = (1<<11); // b
//				GPIOA_BSRR = (1<<10); // c
//				GPIOA_BSRR = (1<<9); // d
//				GPIOA_BSRR = (1<<8); // e
//				GPIOC_BSRR = (1<<9); // f
//				GPIOC_BRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//			case 3:
//				GPIOB_BRR = (1<<13);
//
//				GPIOA_BSRR = (1<<12); // a
//				GPIOA_BSRR = (1<<11); // b
//				GPIOA_BRR = (1<<10); // c
//				GPIOA_BRR = (1<<9); // d
//				GPIOA_BSRR = (1<<8); // e
//				GPIOC_BSRR = (1<<9); // f
//				GPIOC_BSRR = (1<<8); // g
//				GPIOC_BRR = (1<<7);
//				break;
//		}
//		delay_loop(2000);
//	    GPIOC_BSRR = (1<<6);
//	    GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);
//	}
//}

//ISR 설정
void EXTI4_IRQHandler(void){
	if(EXTI4_PR & (1<< 4)){
		EXTI4_PR |= (1<<4);
		for(volatile int i=0; i<50000; i++); // 간단한 debounce delay
		btn_flag = 1;

	}
}

void TIM2_IRQHandler(void)
{
    if (TIM2_SR & 1)  // UIF 플래그
    {
        TIM2_SR &= ~1; // 클리어

        GPIOC_BSRR = (1<<6);                // DIG_1 off
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);  // DIG_2~4 off
        // 4자리 중 현재 자리 선택
        switch(seg_index) {
            case 0: GPIOC_BRR = (1<<6);
                    print_segment(adc_value / 1000);
                    break;
            case 1: GPIOB_BRR = (1<<15);
                    print_segment((adc_value % 1000) / 100);
                    break;
            case 2: GPIOB_BRR = (1<<14);
                    print_segment((adc_value % 100) / 10);
                    break;
            case 3: GPIOB_BRR = (1<<13);
                    print_segment(adc_value % 10);
                    break;
        }

        // 다음 자리로 순환
        seg_index = (seg_index + 1) % 4;
    }
}

