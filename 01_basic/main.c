/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#define RCC_APB2ENR (*(unsigned int*) 0x40021018)
#define RCC_APB1ENR (*(unsigned int*) 0x4002101C)

#define GPIOA 		(*(unsigned int*) 0x40010800)
#define GPIOB 		(*(unsigned int*) 0x40010C00)
#define GPIOC 		(*(unsigned int*) 0x40011000)
#define GPIOD 		(*(unsigned int*) 0x40011400)

#define ADC1 		(*(unsigned int*) 0x40012400)
#define ADC2 		(*(unsigned int*) 0x40012800)

#define GPIOA_CRL 	(*(unsigned int*)0x40010800)
#define GPIOA_CRH 	(*(unsigned int*)0x40010804)
#define GPIOA_IDR 	(*(unsigned int*)0x40010808)
#define GPIOA_ODR 	(*(unsigned int*)0x4001080C)
#define GPIOA_BSRR 	(*(unsigned int*)0x40010810)
#define GPIOA_BRR 	(*(unsigned int*)0x40010814)

#define GPIOB_CRL 	(*(unsigned int*)0x40010C00)
#define GPIOB_CRH 	(*(unsigned int*)0x40010C04)
#define GPIOB_IDR 	(*(unsigned int*)0x40010C08)
#define GPIOB_ODR 	(*(unsigned int*)0x40010C0C)
#define GPIOB_BSRR 	(*(unsigned int*)0x40010C10)
#define GPIOB_BRR 	(*(unsigned int*)0x40010C14)

#define GPIOC_CRL 	(*(unsigned int*)0x40011000)
#define GPIOC_CRH 	(*(unsigned int*)0x40011004)
#define GPIOC_IDR 	(*(unsigned int*)0x40011008)
#define GPIOC_ODR 	(*(unsigned int*)0x4001100C)
#define GPIOC_BSRR 	(*(unsigned int*)0x40011010)
#define GPIOC_BRR 	(*(unsigned int*)0x40011014)

#define GPIOD_CRL 	(*(unsigned int*)0x40011400)
#define GPIOD_CRH 	(*(unsigned int*)0x40011404)
#define GPIOD_IDR 	(*(unsigned int*)0x40011408)
#define GPIOD_ODR 	(*(unsigned int*)0x4001140C)
#define GPIOD_BSRR 	(*(unsigned int*)0x40011410)
#define GPIOD_BRR 	(*(unsigned int*)0x40011414)

#define ADC1_CR2 	(*(unsigned int*) 0x40012408)
#define ADC1_SQR1 	(*(unsigned int*) 0x4001242C)
#define ADC1_SQR2 	(*(unsigned int*) 0x40012430)
#define ADC1_SQR3 	(*(unsigned int*) 0x40012434)
#define ADC1_DR 	(*(unsigned int*) 0x4001244C)
#define ADC1_SMPR2 	(*(unsigned int*) 0x40012410)
#define ADC1_SR 	(*(unsigned int*)0x40012400)

#define TIM3 		(*(unsigned int*) 0x40000400)
#define TIM3_PSC 	(*(unsigned int*) 0x40000428)
#define TIM3_ARR 	(*(unsigned int*) 0x4000042C)
#define TIM3_CCR2 	(*(unsigned int*) 0x40000438)
#define TIM3_CCER 	(*(unsigned int*) 0x40000420)
#define TIM3_CCMR1 	(*(unsigned int*) 0x40000418)
#define TIM3_CR1 	(*(unsigned int*) 0x40000400)
#define TIM3_EGR 	(*(unsigned int*) 0x40000414)

#define EXTI_IMR 	(*(unsigned int*) 0x40010400)
#define EXTI_EMR	(*(unsigned int*) 0x40010404)
#define EXTI_RTSR	(*(unsigned int*) 0x40010408)
#define EXTI_FTSR	(*(unsigned int*) 0x4001040C)
#define EXTI_SWIER	(*(unsigned int*) 0x40010410)
#define EXTI_PR		(*(unsigned int*) 0x40010414)

#define NVIC_ISER0 (*(unsigned int*) 0xE000E100)
#define EXTI4_PR (*(unsigned int*) 0x40010414)
#define EXTI 0x40010400
#define AFIO 0x40010000
#define NVIC 0xE000E100
#define AFIO_EXTICR2 (*(unsigned int*) 0x4001000C)


#define ADC_CHECK_ON()   (GPIOC_BSRR = (1<<13))
#define ADC_CHECK_OFF()  (GPIOC_BRR  = (1<<13))

#define LED_CHECK_ON()   (GPIOA_BSRR = (1 << 1))
#define LED_CHECK_OFF()  (GPIOA_BRR  = (1 << 1))

#define SEG_CHECK_ON()   (GPIOA_BSRR = (1 << 4))
#define SEG_CHECK_OFF()  (GPIOA_BRR  = (1 << 4))


#include <stdint.h>


static uint16_t adc_value;
static uint32_t led_delay;
volatile uint8_t btn_flag = 0; // 전역 변수 선언
volatile uint8_t stop_mode = 0;
volatile uint8_t led_idx = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void LEDs_sqeuence();
void delay_loop(uint32_t time);
void seven_seg(uint16_t adc_value);
void print_segment(uint8_t number);
void print_stop();
void print_fast();

int main(void)
{
	/**************CLK Setting**************/
	RCC_APB2ENR |= (1 << 2); // GPIOA EN
	RCC_APB2ENR |= (1 << 3); // GPIOB EN
	RCC_APB2ENR |= (1 << 4); // GPIOC EN
	RCC_APB2ENR |= (1 << 5); // GPIOD EN

	RCC_APB1ENR |= (1 << 1); // TIM2 EN
	RCC_APB2ENR |= (1 << 0); // AFIO EN

	// ADC CLK
	RCC_APB2ENR |= (1 << 9); // ADC1 EN
	RCC_APB2ENR |= (1 << 10); // ADC2 EN

	/*************************************/


	/***************LEDs GPIO SET ******************/

	/*
	- **PC5 - LED_1**
	- **PB0 - LED_2**
	- **PB1 - LED_3**
	- **PB2 - LED_4**
	- **PB10 - LED_5**
	- **PB11 - LED_6**
	*/

	GPIOC_CRH &= ~(0xFFF << 20);   // Clear PC13~15
	GPIOC_CRH |=  (0x111 << 20);   // Output, 10MHz

	/* PA1, PA4 Output Push-Pull, 10MHz */
	GPIOA_CRL &= ~(0xF << (1 * 4));   // PA1 Clear
	GPIOA_CRL |=  (0x1 << (1 * 4));   // Output 10MHz, PP

	GPIOA_CRL &= ~(0xF << (4 * 4));   // PA4 Clear
	GPIOA_CRL |=  (0x1 << (4 * 4));   // Output 10MHz, PP

	GPIOA_BRR = (1 << 1) | (1 << 4);
	GPIOC_BRR = (1<<13) | (1<<14) | (1<<15);


	GPIOA_CRL &= ~(0xF << 24); // ADC PA6 SET

	GPIOC_CRL &= ~(0xF << 20); // PC5 Clear
	GPIOC_CRL |= (1<<20);
	GPIOB_CRL &= ~(0xF << 0); // PB0 Clear
	GPIOB_CRL |= (1<<0);
	GPIOB_CRL &= ~(0xF << 4); // PB1 Clear
	GPIOB_CRL |= (1<<4);
	GPIOB_CRL &= ~(0xF << 8); // PB2 Clear
	GPIOB_CRL |= (1<<8);
	GPIOB_CRH &= ~(0xF << 8); // PB10 Clear
	GPIOB_CRH |= (1<<8);
	GPIOB_CRH &= ~(0xF << 12); // PB11 Clear
	GPIOB_CRH |= (1<<12);
	/***********************************************/

	GPIOC_BRR = (1 << 5);
	GPIOB_BRR = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 10) | (1 << 11);


	/**********************7-Segment GPIO Set**************************/

	/*
		- **PA12 - DIG_A**
		- **PA11 - DIG_B**
		- **PA10 - DIG_C**
		- **PA9 - DIG_D**
		- **PA8 - DIG_E**
		- **PC9 - DIG_F**
		- **PC8 - DIG_G**
		- **PC7 - DIG_H**
		- **PC6 - DIG_1_com**
		- **PB15 - DIG_2_com**
		- **PB14 - DIG_3_com**
		- **PB13 - DIG_4_com**
	 */
	GPIOA_CRH &= ~(0xF << 16); // PA12 Clear
	GPIOA_CRH |= (1<<16);

	GPIOA_CRH &= ~(0xF << 12); // PA11 - DIG_B
	GPIOA_CRH |= (1<<12);

	GPIOA_CRH &= ~(0xF << 8); // PA10 - DIG_C
	GPIOA_CRH |= (1<<8);

	GPIOA_CRH &= ~(0xF << 4);  //PA9 - DIG_D
	GPIOA_CRH |= (1<<4);

	GPIOA_CRH &= ~(0xF << 0); // PA8 - DIG_E
	GPIOA_CRH |= (1<<0);

	GPIOC_CRH &= ~(0xF << 4); // PC9 - DIG_F
	GPIOC_CRH |= (1<<4);

	GPIOC_CRH &= ~(0xF << 0); // PC8 - DIG_G
	GPIOC_CRH |= (1<<0);

	GPIOC_CRL &= ~(0xF << 28); // PC7 - DIG_H
	GPIOC_CRL |= (1<<28);

	GPIOC_CRL &= ~(0xF << 24); // PC6 - DIG_1_com
	GPIOC_CRL |= (1<<24);

	GPIOB_CRH &= ~(0xF << 28); // PB15 - DIG_2_com
	GPIOB_CRH |= (1<<28);

	GPIOB_CRH &= ~(0xF << 24); //PB14 - DIG_3_com
	GPIOB_CRH |= (1<<24);

	GPIOB_CRH &= ~(0xF << 20); //PB13 - DIG_4_com
	GPIOB_CRH |= (1<<20);

	/*********************************************************/





	/**********************ADC************************/

	ADC1_CR2 |= (1<<0); // ADC전원 ON
	for (volatile int i = 0; i < 10000; i++); //안정화 대기


	ADC1_SMPR2 |= (7<<18);
	ADC1_SQR3 = 6;
	ADC1_CR2 |= (1<<1);
	ADC1_CR2 |= (1<<22);
	ADC1_CR2 |= (1<<0);
	/************************************************/


	/***********************PWM***************************/

	GPIOA_CRL &= 	~(0xF << 28); // PA7 CRL
	GPIOA_CRL |= 	(0xB << 28);  // PA7 AFIO Set 1011

	// 3. PWM 기본 설정
	TIM3_PSC = 72 - 1;       // 1 MHz
	TIM3_ARR = 20000 - 1;    // 20ms (50Hz)
	TIM3_CCR2 = 1500;        // Duty 7.5%

	TIM3_CCMR1 &= ~(7<<12);
	TIM3_CCMR1 |= (6<<12);
	TIM3_CCMR1 |= (1<<11);
	TIM3_CCER |= (1<<4);

	TIM3_CR1 |= (1 << 7);
	TIM3_EGR |= (1 << 0);
	TIM3_CR1 |= (1 << 0);
	/*****************************************************/



	/******************************Interrupt***********************************/
	//PC5를 gpio output으로 설정
	GPIOC_CRL &= ~(0xF << 20);
	GPIOC_CRL |= (1<<20);

	//PC4 입력
	GPIOC_CRL &= ~(0xF << 16);
	GPIOC_CRL |= (2<<18);
	GPIOC_ODR  |=  (1 << 4);     // Pull-up 활성화

	//EXTI 2초기화
	AFIO_EXTICR2 &= ~(0xF<<0);
	//EXTI PC interrupt 설정
	AFIO_EXTICR2 |= (0x2<<0);

	EXTI_IMR |= (1<<4);
	EXTI_FTSR |= (1<<4);


	//NVIC IRQ 설정
	NVIC_ISER0 |= (1<<10);
	/***************************************************************************/



    /* Loop forever */
	while(1){

	    if (btn_flag)
	    {
	        btn_flag = 0;
	        stop_mode = !stop_mode;  // 토글
	    }

	    if (stop_mode)
	    {
	        print_stop();  // stop 상태 유지
	        TIM3_CCR2 = 0;
			SEG_CHECK_ON();
			delay_loop(2000);
			SEG_CHECK_OFF();

	        continue;      // 아래 ADC, PWM 무시
	    }
	    ADC_CHECK_ON();

		ADC1_CR2 |= (1 << 22);   // SWSTART trigger
		while (!(ADC1_SR & (1 << 1)));     // EOC (End of Conversion) 기다림
		adc_value = (uint16_t)ADC1_DR;     // 결과 레지스터 읽기


		delay_loop(2000);
		ADC_CHECK_OFF();

		if(adc_value > 4010){
			TIM3_CCR2 = 0;
			SEG_CHECK_ON();
			print_fast();
			SEG_CHECK_OFF();
		}
		else if(adc_value < 1000){
			TIM3_CCR2 = 0;
			SEG_CHECK_ON();
			print_stop();
			SEG_CHECK_OFF();

		}
		else{

			led_idx%=6;
			LED_CHECK_ON();
			LEDs_sqeuence(led_idx);
			LED_CHECK_OFF();
			led_idx++;

			SEG_CHECK_ON();
			seven_seg(adc_value);
		    SEG_CHECK_OFF();

			TIM3_CCR2 = (adc_value*(TIM3_ARR+1)) / 4095;

		}
	}
}

void LEDs_sqeuence(int idx)
{
	const uint32_t delay_table[8] = {300000, 200000, 130000, 80000, 50000, 30000, 15000, 7000};
	uint8_t level = adc_value / 512;  // 0~7
	led_delay = delay_table[level];

	switch(idx){
		case 0:
			GPIOC_BSRR = (1<<5);
			GPIOB_BRR = (1<<0);
			GPIOB_BRR = (1<<1);
			GPIOB_BRR = (1<<2);
			GPIOB_BRR = (1<<10);
			GPIOB_BRR = (1<<11);
			break;
		case 1:
			GPIOC_BRR = (1<<5);
			GPIOB_BSRR = (1<<0);
			GPIOB_BRR = (1<<1);
			GPIOB_BRR = (1<<2);
			GPIOB_BRR = (1<<10);
			GPIOB_BRR = (1<<11);
			break;
		case 2:
			GPIOC_BRR = (1<<5);
			GPIOB_BRR = (1<<0);
			GPIOB_BSRR = (1<<1);
			GPIOB_BRR = (1<<2);
			GPIOB_BRR = (1<<10);
			GPIOB_BRR = (1<<11);
			break;
		case 3:
			GPIOC_BRR = (1<<5);
			GPIOB_BRR = (1<<0);
			GPIOB_BRR = (1<<1);
			GPIOB_BSRR = (1<<2);
			GPIOB_BRR = (1<<10);
			GPIOB_BRR = (1<<11);
			break;
		case 4:
			GPIOC_BRR = (1<<5);
			GPIOB_BRR = (1<<0);
			GPIOB_BRR = (1<<1);
			GPIOB_BRR = (1<<2);
			GPIOB_BSRR = (1<<10);
			GPIOB_BRR = (1<<11);
			break;
		case 5:
			GPIOC_BRR = (1<<5);
			GPIOB_BRR = (1<<0);
			GPIOB_BRR = (1<<1);
			GPIOB_BRR = (1<<2);
			GPIOB_BRR = (1<<10);
			GPIOB_BSRR = (1<<11);
			break;

	}
	delay_loop(led_delay);
}

void delay_loop(uint32_t time)
{
    for (volatile uint32_t i = 0; i < time; i++);
}

void seven_seg(uint16_t adc_value)
{

	uint8_t adc_value_1000 = adc_value/1000;     // PC6 - DIG_1_com
	uint8_t adc_value_100 = (adc_value%1000)/100; //PB15 - DIG_2_com
	uint8_t adc_value_10 = (adc_value%100)/10;   //PB14 - DIG_3_com
	uint8_t adc_value_1 = adc_value%10;			 //PB13 - DIG_4_com

	for(int i=0; i<4; i++){
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);

		switch(i){
			case 0:
				GPIOC_BRR = (1<<6);
				print_segment(adc_value_1000);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 1:
				GPIOB_BRR = (1<<15);
				print_segment(adc_value_100);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 2:
				GPIOB_BRR = (1<<14);
				print_segment(adc_value_10);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 3:
				GPIOB_BRR = (1<<13);
				print_segment(adc_value_1); 	//print adc_value_1000
//				delay_loop(1000);
				break;
		}

	}
	/*stop, fast */
	/* 0 1 2 3 4 5 6 7 8 9 */

}

void print_segment(uint8_t number)
{
	/*
		- **PA12 - DIG_A**
		- **PA11 - DIG_B**
		- **PA10 - DIG_C**
		- **PA9 - DIG_D**
		- **PA8 - DIG_E**
		- **PC9 - DIG_F**
		- **PC8 - DIG_G**

		- **PC7 - DIG_H**
		- **PC6 - DIG_1_com**
		- **PB15 - DIG_2_com**
		- **PB14 - DIG_3_com**
		- **PB13 - DIG_4_com**
	 */
	GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
	GPIOC_BRR = (1<<9) | (1<<8);

	switch(number){
		case 0:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 1:
			GPIOA_BRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 2:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 3:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 4:
			GPIOA_BRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 5:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 6:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 7:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 8:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 9:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
	}
	delay_loop(2000);
}


void print_fast(void){
	GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
	GPIOC_BRR = (1<<9) | (1<<8);

	for(int i=0; i<4; i++){
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);

		switch(i){
			case 0:
				GPIOC_BRR = (1<<6);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
			case 1:
				GPIOB_BRR = (1<<15);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
			case 2:
				GPIOB_BRR = (1<<14);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
			case 3:
				GPIOB_BRR = (1<<13);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
		}
		delay_loop(2000);
	    GPIOC_BSRR = (1<<6);
	    GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);
	}
}

void print_stop(void){
	GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
	GPIOC_BRR = (1<<9) | (1<<8);

	for(int i=0; i<4; i++){
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);

		switch(i){
			case 0:
				GPIOC_BRR = (1<<6);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
			case 1:
				GPIOB_BRR = (1<<15);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
			case 2:
				GPIOB_BRR = (1<<14);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
			case 3:
				GPIOB_BRR = (1<<13);

				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break;
		}
		delay_loop(2000);
	    GPIOC_BSRR = (1<<6);
	    GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);
	}
}

//ISR 설정
void EXTI4_IRQHandler(void){
	if(EXTI4_PR & (1<< 4)){
		EXTI4_PR |= (1<<4);
		for(volatile int i=0; i<50000; i++); // 간단한 debounce delay
		btn_flag = 1;

	}
}
