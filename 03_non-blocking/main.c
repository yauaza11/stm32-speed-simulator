/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#define RCC_APB2ENR (*(volatile unsigned int*) 0x40021018)
#define RCC_APB1ENR (*(volatile unsigned int*) 0x4002101C)

#define GPIOA 		(*(volatile unsigned int*) 0x40010800)
#define GPIOB 		(*(volatile unsigned int*) 0x40010C00)
#define GPIOC 		(*(volatile unsigned int*) 0x40011000)
#define GPIOD 		(*(volatile unsigned int*) 0x40011400)

#define ADC1 		(*(volatile unsigned int*) 0x40012400)
#define ADC2 		(*(volatile unsigned int*) 0x40012800)

#define GPIOA_CRL 	(*(volatile unsigned int*)0x40010800)
#define GPIOA_CRH 	(*(volatile unsigned int*)0x40010804)
#define GPIOA_IDR 	(*(volatile unsigned int*)0x40010808)
#define GPIOA_ODR 	(*(volatile unsigned int*)0x4001080C)
#define GPIOA_BSRR 	(*(volatile unsigned int*)0x40010810)
#define GPIOA_BRR 	(*(volatile unsigned int*)0x40010814)

#define GPIOB_CRL 	(*(volatile unsigned int*)0x40010C00)
#define GPIOB_CRH 	(*(volatile unsigned int*)0x40010C04)
#define GPIOB_IDR 	(*(volatile unsigned int*)0x40010C08)
#define GPIOB_ODR 	(*(volatile unsigned int*)0x40010C0C)
#define GPIOB_BSRR 	(*(volatile unsigned int*)0x40010C10)
#define GPIOB_BRR 	(*(volatile unsigned int*)0x40010C14)

#define GPIOC_CRL 	(*(volatile unsigned int*)0x40011000)
#define GPIOC_CRH 	(*(volatile unsigned int*)0x40011004)
#define GPIOC_IDR 	(*(volatile unsigned int*)0x40011008)
#define GPIOC_ODR 	(*(volatile unsigned int*)0x4001100C)
#define GPIOC_BSRR 	(*(volatile unsigned int*)0x40011010)
#define GPIOC_BRR 	(*(volatile unsigned int*)0x40011014)

#define GPIOD_CRL 	(*(volatile unsigned int*)0x40011400)
#define GPIOD_CRH 	(*(volatile unsigned int*)0x40011404)
#define GPIOD_IDR 	(*(volatile unsigned int*)0x40011408)
#define GPIOD_ODR 	(*(volatile unsigned int*)0x4001140C)
#define GPIOD_BSRR 	(*(volatile unsigned int*)0x40011410)
#define GPIOD_BRR 	(*(volatile unsigned int*)0x40011414)

#define ADC1_CR2 	(*(volatile unsigned int*) 0x40012408)
#define ADC1_CR1 	(*(volatile unsigned int*) 0x40012404)
#define ADC1_SQR1 	(*(volatile unsigned int*) 0x4001242C)
#define ADC1_SQR2 	(*(volatile unsigned int*) 0x40012430)
#define ADC1_SQR3 	(*(volatile unsigned int*) 0x40012434)
#define ADC1_DR 	(*(volatile unsigned int*) 0x4001244C)
#define ADC1_SMPR2 	(*(volatile unsigned int*) 0x40012410)
#define ADC1_SR 	(*(volatile unsigned int*)0x40012400)

#define TIM2		(*(volatile unsigned int*) 0x40000000)
#define TIM2_PSC 	(*(volatile unsigned int*) 0x40000028)
#define TIM2_ARR 	(*(volatile unsigned int*) 0x4000002C)
#define TIM2_CCR2 	(*(volatile unsigned int*) 0x40000038)
#define TIM2_CCER 	(*(volatile unsigned int*) 0x40000020)
#define TIM2_CCMR1 	(*(volatile unsigned int*) 0x40000018)
#define TIM2_CR1 	(*(volatile unsigned int*) 0x40000000)
#define TIM2_EGR 	(*(volatile unsigned int*) 0x40000014)
#define TIM2_SR 	(*(volatile unsigned int*) 0x40000010)
#define TIM2_DIER	(*(volatile unsigned int*) 0x4000000C)

#define TIM3 		(*(volatile unsigned int*) 0x40000400)
#define TIM3_PSC 	(*(volatile unsigned int*) 0x40000428)
#define TIM3_ARR 	(*(volatile unsigned int*) 0x4000042C)
#define TIM3_CCR2 	(*(volatile unsigned int*) 0x40000438)
#define TIM3_CCER 	(*(volatile unsigned int*) 0x40000420)
#define TIM3_CCMR1 	(*(volatile unsigned int*) 0x40000418)
#define TIM3_CR1 	(*(volatile unsigned int*) 0x40000400)
#define TIM3_EGR 	(*(volatile unsigned int*) 0x40000414)

#define TIM4		(*(volatile unsigned int*) 0x40000800)
#define TIM4_PSC 	(*(volatile unsigned int*) 0x40000828)
#define TIM4_ARR 	(*(volatile unsigned int*) 0x4000082C)
#define TIM4_CCR2 	(*(volatile unsigned int*) 0x40000838)
#define TIM4_CCER 	(*(volatile unsigned int*) 0x40000820)
#define TIM4_CCMR1 	(*(volatile unsigned int*) 0x40000818)
#define TIM4_CR1 	(*(volatile unsigned int*) 0x40000800)
#define TIM4_EGR 	(*(volatile unsigned int*) 0x40000814)
#define TIM4_SR 	(*(volatile unsigned int*) 0x40000810)
#define TIM4_DIER	(*(volatile unsigned int*) 0x4000080C)

#define EXTI_IMR 	(*(volatile unsigned int*) 0x40010400)
#define EXTI_EMR	(*(volatile unsigned int*) 0x40010404)
#define EXTI_RTSR	(*(volatile unsigned int*) 0x40010408)
#define EXTI_FTSR	(*(volatile unsigned int*) 0x4001040C)
#define EXTI_SWIER	(*(volatile unsigned int*) 0x40010410)
#define EXTI_PR		(*(volatile unsigned int*) 0x40010414)

#define NVIC_ISER0 (*(volatile unsigned int*) 0xE000E100)
#define NVIC_ISER1 (*(volatile unsigned int*) 0xE000E104)

#define EXTI4_PR (*(unsigned int*) 0x40010414)
#define AFIO_EXTICR2 (*(unsigned int*) 0x4001000C)



#include <stdint.h>


volatile uint16_t adc_value;
volatile uint8_t btn_pressed = 0;
volatile uint8_t debounce_active = 0;
volatile uint8_t stop_mode = 0;
volatile uint8_t seg_index = 0;
volatile uint8_t adc_state = 0; // 0: normal, 1: fast, 2: stop
volatile uint8_t led_update_flag = 0;
volatile uint8_t led_tick_counter = 0;
volatile uint8_t led_delay_ticks = 100;
volatile uint8_t led_index = 0;



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void seven_seg(uint16_t adc_value);
void print_segment(uint8_t number);
void print_stop();
void print_fast();
void update_led_pattern(uint8_t idx);

int main(void)
{
	/**************CLK Setting**************/
	RCC_APB2ENR |= (1 << 2); // GPIOA EN
	RCC_APB2ENR |= (1 << 3); // GPIOB EN
	RCC_APB2ENR |= (1 << 4); // GPIOC EN
	RCC_APB2ENR |= (1 << 5); // GPIOD EN

	RCC_APB1ENR |= (1 << 3); // TIM5 EN
	RCC_APB1ENR |= (1 << 0); //TIM2 EN
	RCC_APB1ENR |= (1 << 1); // TIM3 EN
	RCC_APB1ENR |= (1 << 2); //	TIM4 EN

	RCC_APB2ENR |= (1 << 0); // AFIO EN

	// ADC CLK
	RCC_APB2ENR |= (1 << 9); // ADC1 EN
	RCC_APB2ENR |= (1 << 10); // ADC2 EN

	/*************************************/


	/***************LEDs GPIO SET ******************/

	/*
	- **PC5 - LED_1**
	- **PB0 - LED_2**
	- **PB1 - LED_3**
	- **PB2 - LED_4**
	- **PB10 - LED_5**
	- **PB11 - LED_6**
	*/

	GPIOA_CRL &= ~(0xF << 24); // ADC PA6 SET

	GPIOC_CRL &= ~(0xF << 20); // PC5 Clear
	GPIOC_CRL |= (1<<20);
	GPIOB_CRL &= ~(0xF << 0); // PB0 Clear
	GPIOB_CRL |= (1<<0);
	GPIOB_CRL &= ~(0xF << 4); // PB1 Clear
	GPIOB_CRL |= (1<<4);
	GPIOB_CRL &= ~(0xF << 8); // PB2 Clear
	GPIOB_CRL |= (1<<8);
	GPIOB_CRH &= ~(0xF << 8); // PB10 Clear
	GPIOB_CRH |= (1<<8);
	GPIOB_CRH &= ~(0xF << 12); // PB11 Clear
	GPIOB_CRH |= (1<<12);
	/***********************************************/

	GPIOC_BRR = (1 << 5);
	GPIOB_BRR = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 10) | (1 << 11);


	/**********************7-Segment GPIO Set**************************/

	/*
		- **PA12 - DIG_A**
		- **PA11 - DIG_B**
		- **PA10 - DIG_C**
		- **PA9 - DIG_D**
		- **PA8 - DIG_E**
		- **PC9 - DIG_F**
		- **PC8 - DIG_G**
		- **PC7 - DIG_H**
		- **PC6 - DIG_1_com**
		- **PB15 - DIG_2_com**
		- **PB14 - DIG_3_com**
		- **PB13 - DIG_4_com**
	 */
	GPIOA_CRH &= ~(0xF << 16); // PA12 Clear
	GPIOA_CRH |= (1<<16);

	GPIOA_CRH &= ~(0xF << 12); // PA11 - DIG_B
	GPIOA_CRH |= (1<<12);

	GPIOA_CRH &= ~(0xF << 8); // PA10 - DIG_C
	GPIOA_CRH |= (1<<8);

	GPIOA_CRH &= ~(0xF << 4);  //PA9 - DIG_D
	GPIOA_CRH |= (1<<4);

	GPIOA_CRH &= ~(0xF << 0); // PA8 - DIG_E
	GPIOA_CRH |= (1<<0);

	GPIOC_CRH &= ~(0xF << 4); // PC9 - DIG_F
	GPIOC_CRH |= (1<<4);

	GPIOC_CRH &= ~(0xF << 0); // PC8 - DIG_G
	GPIOC_CRH |= (1<<0);

	GPIOC_CRL &= ~(0xF << 28); // PC7 - DIG_H
	GPIOC_CRL |= (1<<28);

	GPIOC_CRL &= ~(0xF << 24); // PC6 - DIG_1_com
	GPIOC_CRL |= (1<<24);

	GPIOB_CRH &= ~(0xF << 28); // PB15 - DIG_2_com
	GPIOB_CRH |= (1<<28);

	GPIOB_CRH &= ~(0xF << 24); //PB14 - DIG_3_com
	GPIOB_CRH |= (1<<24);

	GPIOB_CRH &= ~(0xF << 20); //PB13 - DIG_4_com
	GPIOB_CRH |= (1<<20);

	/*********************************************************/

	/**********************ADC************************/

	ADC1_CR2 |= (1<<0); // ADC전원 ON
	ADC1_SMPR2 |= (7<<18);	// 사이클 설정
	ADC1_SQR3 = 6;			// CH6 을 Regular Sequence로 설정
	ADC1_CR2 |= (1<<1); 	// ADC Continous MODE
	ADC1_CR2 |= (1<<0);		// ADC ON

	ADC1_CR1 |= (1<<5); 	// INTERRUPT ENABLE
	ADC1_CR2 |= (1<<22);	// 변환 트리거 시작 -> Continous MODE이므로 한 번만 수행할 것
	NVIC_ISER0 |= (1<<18);

	/************************************************/


	/***********************PWM***************************/

	GPIOA_CRL &= 	~(0xF << 28); // PA7 CRL
	GPIOA_CRL |= 	(0xB << 28);  // PA7 AFIO Set 1011

	// 3. PWM 기본 설정
	TIM3_PSC = 72 - 1;       // 1 MHz
	TIM3_ARR = 50 - 1;    // 20ms (50Hz)
	TIM3_CCR2 = 0;

	TIM3_CCMR1 &= ~(7<<12);
	TIM3_CCMR1 |= (6<<12);
	TIM3_CCMR1 |= (1<<11);
	TIM3_CCER |= (1<<4);

	TIM3_CR1 |= (1 << 7);
	TIM3_EGR |= (1 << 0);
	TIM3_CR1 |= (1 << 0);
	/*****************************************************/



	/******************************Interrupt***********************************/
	//PC5를 gpio output으로 설정
	GPIOC_CRL &= ~(0xF << 20);
	GPIOC_CRL |= (1<<20);

	//PC4 입력
	GPIOC_CRL &= ~(0xF << 16);
	GPIOC_CRL |= (2<<18);
	GPIOC_ODR  |=  (1 << 4);     // Pull-up 활성화

	//EXTI 2초기화
	AFIO_EXTICR2 &= ~(0xF<<0);
	//EXTI PC interrupt 설정
	AFIO_EXTICR2 |= (0x2<<0);

	EXTI_IMR |= (1<<4);
	EXTI_FTSR |= (1<<4);


	//NVIC IRQ 설정
	NVIC_ISER0 |= (1<<10);

	// TIM4 Break Button
	TIM4_DIER |= (1 << 0); // Interrupt Enable
    TIM4_PSC = 7200 - 1;   // 0.1ms tick
    TIM4_ARR = 100-1;        // 10ms
	NVIC_ISER0 |= (1 << 30); // TIM4 IRQ enable

	NVIC_ISER1 |= (1 << 18); // Enable TIM5 IRQ (IRQ #50)
	/***************************************************************************/


	/***********7 Segment Timer Interrupt Improved*************/

	TIM2_PSC = 7200-1;
	TIM2_ARR = 10 - 1;
	TIM2_EGR |= (1 << 0);  // UG (Update generation) 반드시 필요
	TIM2_SR &= ~(1 << 0);  // UIF 클리어
	TIM2_DIER |= (1 << 0);  // UIE (Update Interrupt Enable)
	TIM2_CR1  |= (1 << 0);  // CEN (Timer Enable)
	//TIM2_SR	&= ~(1 << 0);
	NVIC_ISER0 |= (1 << 28); // IRQ28은 TIM2 (NVIC 벡터 참고)

	/********************************/


    /* Loop forever */
	while(1){

	    if (btn_pressed)
	    {
	        btn_pressed = 0;
	        stop_mode = !stop_mode;
	    }

	    if (stop_mode)
	    {
	        print_stop();  // STOP 상태 유지
	        TIM3_CCR2 = 0; // 모터 정지
	        continue;      // ADC 동작 중단
	    }


	    if(led_update_flag)
	    {
	    	led_update_flag = 0;
			led_index++;
	    	led_index %= 6;
	    }

	    switch(adc_state){
	    // 0: normal, 1: fast, 2: stop
			case 0:
				TIM3_CCR2 = (adc_value * 70) / 4095; // 0~49 듀티
				if (TIM3_CCR2 > TIM3_ARR) TIM3_CCR2 = TIM3_ARR;
				update_led_pattern(led_index);
				break;
			case 1:
				TIM3_CCR2 = 0; // 모터 정지
				print_fast();
				break;
			case 2:
				TIM3_CCR2 = 0; // 모터 정지
				print_stop();
				break;
		}
	}
}

void update_led_pattern(uint8_t idx)
{
    GPIOC_BRR = (1<<5);
    GPIOB_BRR = (1<<0)|(1<<1)|(1<<2)|(1<<10)|(1<<11);

    switch(idx){
        case 0: GPIOC_BSRR = (1<<5); break;
        case 1: GPIOB_BSRR = (1<<0); break;
        case 2: GPIOB_BSRR = (1<<1); break;
        case 3: GPIOB_BSRR = (1<<2); break;
        case 4: GPIOB_BSRR = (1<<10); break;
        case 5: GPIOB_BSRR = (1<<11); break;
    }
}

void seven_seg(uint16_t adc_value)
{

	uint8_t adc_value_1000 = adc_value/1000;     // PC6 - DIG_1_com
	uint8_t adc_value_100 = (adc_value%1000)/100; //PB15 - DIG_2_com
	uint8_t adc_value_10 = (adc_value%100)/10;   //PB14 - DIG_3_com
	uint8_t adc_value_1 = adc_value%10;			 //PB13 - DIG_4_com

	for(int i=0; i<4; i++){
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);

		switch(i){
			case 0:
				GPIOC_BRR = (1<<6);
				print_segment(adc_value_1000);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 1:
				GPIOB_BRR = (1<<15);
				print_segment(adc_value_100);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 2:
				GPIOB_BRR = (1<<14);
				print_segment(adc_value_10);	//print adc_value_1000
//				delay_loop(1000);
				break;
			case 3:
				GPIOB_BRR = (1<<13);
				print_segment(adc_value_1); 	//print adc_value_1000
//				delay_loop(1000);
				break;
		}

	}
	/*stop, fast */
	/* 0 1 2 3 4 5 6 7 8 9 */

}

void print_segment(uint8_t number)
{
	/*
		- **PA12 - DIG_A**
		- **PA11 - DIG_B**
		- **PA10 - DIG_C**
		- **PA9 - DIG_D**
		- **PA8 - DIG_E**
		- **PC9 - DIG_F**
		- **PC8 - DIG_G**

		- **PC7 - DIG_H**
		- **PC6 - DIG_1_com**
		- **PB15 - DIG_2_com**
		- **PB14 - DIG_3_com**
		- **PB13 - DIG_4_com**
	 */
	GPIOA_BRR = (1<<12) | (1<<11) | (1<<10) | (1<<9) | (1<<8);
	GPIOC_BRR = (1<<9) | (1<<8);

	switch(number){
		case 0:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 1:
			GPIOA_BRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 2:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 3:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 4:
			GPIOA_BRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 5:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 6:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 7:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 8:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BSRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
		case 9:
			GPIOA_BSRR = (1<<12); // a
			GPIOA_BSRR = (1<<11); // b
			GPIOA_BSRR = (1<<10); // c
			GPIOA_BSRR = (1<<9); // d
			GPIOA_BRR = (1<<8); // e
			GPIOC_BSRR = (1<<9); // f
			GPIOC_BSRR = (1<<8); // g
			GPIOC_BRR = (1<<7);
			break;
	}
}

void print_fast(void)
{
    uint8_t letters[4] = {'F','A','S','T'};
    for(int i=0; i<4; i++)
    {
        // 모든 자리 끄기
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15)|(1<<14)|(1<<13);

        // 모든 segment 끄기
        GPIOA_BRR = (1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8);
        GPIOC_BRR = (1<<9)|(1<<8);

        switch(i)
        {
            case 0: GPIOC_BRR = (1<<6); break;   // DIG_1 ON
            case 1: GPIOB_BRR = (1<<15); break;  // DIG_2 ON
            case 2: GPIOB_BRR = (1<<14); break;  // DIG_3 ON
            case 3: GPIOB_BRR = (1<<13); break;  // DIG_4 ON
        }

        // 글자별 segment 패턴 표시
        switch(letters[i])
        {
            case 'F':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
				break; // a,f,g
            case 'A':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'S':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'T':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
        }
    }
}

void print_stop(void)
{
    uint8_t letters[4] = {'S','T','O','P'};
    for(int i=0; i<4; i++)
    {
        // 전체 off
        GPIOC_BSRR = (1<<6);
        GPIOB_BSRR = (1<<15)|(1<<14)|(1<<13);
        GPIOA_BRR = (1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8);
        GPIOC_BRR = (1<<9)|(1<<8);

        // 자리 선택
        switch(i)
        {
            case 0: GPIOC_BRR = (1<<6); break;
            case 1: GPIOB_BRR = (1<<15); break;
            case 2: GPIOB_BRR = (1<<14); break;
            case 3: GPIOB_BRR = (1<<13); break;
        }

        // 글자 세그먼트 표시
        switch(letters[i])
        {
            case 'S':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'T':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BRR = (1<<8); // e
				GPIOC_BRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'O':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BSRR = (1<<10); // c
				GPIOA_BSRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
            case 'P':
				GPIOA_BSRR = (1<<12); // a
				GPIOA_BSRR = (1<<11); // b
				GPIOA_BRR = (1<<10); // c
				GPIOA_BRR = (1<<9); // d
				GPIOA_BSRR = (1<<8); // e
				GPIOC_BSRR = (1<<9); // f
				GPIOC_BSRR = (1<<8); // g
				GPIOC_BRR = (1<<7);
            	break;
        }
    }
}


//Break 버튼 인터럽트
void EXTI4_IRQHandler(void){
	if(EXTI4_PR & (1<< 4)){
		EXTI4_PR |= (1<<4);

		if (debounce_active) return;
		debounce_active = 1;
        // 10ms 디바운스용 타이머 시작
        TIM4_CR1 |= (1 << 0);
	}
}

void TIM2_IRQHandler(void)
{
    if (TIM2_SR & 1)  // UIF 플래그
    {
        TIM2_SR &= ~1; // 클리어

        GPIOC_BSRR = (1<<6);                // DIG_1 off
        GPIOB_BSRR = (1<<15) | (1<<14) | (1<<13);  // DIG_2~4 off
        // 4자리 중 현재 자리 선택
        switch(seg_index) {
            case 0: GPIOC_BRR = (1<<6);
                    print_segment(adc_value / 1000);
                    break;
            case 1: GPIOB_BRR = (1<<15);
                    print_segment((adc_value % 1000) / 100);
                    break;
            case 2: GPIOB_BRR = (1<<14);
                    print_segment((adc_value % 100) / 10);
                    break;
            case 3: GPIOB_BRR = (1<<13);
                    print_segment(adc_value % 10);
                    break;
        }

        // 다음 자리로 순환
        seg_index = (seg_index + 1) % 4;

		led_tick_counter++;
		if(led_tick_counter >= led_delay_ticks){
			led_tick_counter = 0;
			led_update_flag = 1;
		}
    }
}

void TIM4_IRQHandler(void)
{
	if(TIM4_SR&1){

		TIM4_SR &= ~1;
		TIM4_CR1 &= ~(1<<0); // 타이머 정지

		btn_pressed = 1;		// 실제 버튼 이벤트 발생
		debounce_active = 0; 	// 다시 버튼 허용
	}
}

void ADC1_2_IRQHandler(void){
	if(ADC1_SR & (1<<1)){
		adc_value = (uint16_t)ADC1_DR;
		ADC1_SR &= ~(1<<1);

        if (adc_value > 4000)
            adc_state = 1; // FAST
        else if (adc_value < 1000)
            adc_state = 2; // STOP
        else
            adc_state = 0; // NORMAL

        led_delay_ticks = 10 + (4095 - adc_value) / 45;

	}
}
